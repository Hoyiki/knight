{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HTMLElementSource = void 0;\n\nconst pipeline_1 = require(\"./pipeline\");\n\nconst source_1 = require(\"./source\");\n\nconst profile_1 = require(\"./profile\");\n\nconst shader_1 = require(\"./shader\");\n\nconst gl_matrix_1 = require(\"gl-matrix\");\n\nconst loglevel_1 = require(\"./loglevel\");\n\nlet latest = 1;\nlet byId = new Map();\n\nclass HTMLElementSource extends source_1.Source {\n  constructor(_video, _pipeline) {\n    super();\n    this._video = _video;\n    this._pipeline = _pipeline;\n    this._isPaused = true;\n    this._hadFrames = false;\n    this._isUserFacing = false;\n    this._cameraToScreenRotation = 0;\n    this._isUploadFrame = true;\n    this._computedTransformRotation = -1;\n    this._computedFrontCameraRotation = false;\n    this._cameraUvTransform = gl_matrix_1.mat4.create();\n    this._cameraVertexTransform = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n    this._framebufferWidth = 0;\n    this._framebufferHeight = 0;\n    this._framebufferId = null;\n    this._renderTexture = null;\n    let video = this._video;\n\n    if (this._video instanceof HTMLVideoElement) {\n      video.addEventListener(\"loadedmetadata\", () => {\n        this._hadFrames = true;\n      });\n    } else {\n      this._hadFrames = true;\n    }\n\n    this._resetGLContext = this._resetGLContext.bind(this);\n    let p = pipeline_1.Pipeline.get(this._pipeline);\n    if (p) p.onGLContextReset.bind(this._resetGLContext);\n  }\n\n  static createVideoElementSource(p, element) {\n    let ret = latest++;\n    byId.set(ret, new HTMLElementSource(element, p));\n    loglevel_1.zcout(\"html_element_source_t initialized\");\n    return ret;\n  }\n\n  static getVideoElementSource(m) {\n    return byId.get(m);\n  }\n\n  _resetGLContext() {\n    this._currentVideoTexture = undefined;\n    this._framebufferId = null;\n    this._renderTexture = null;\n    this._vertexBuffer = undefined;\n    this._indexBuffer = undefined;\n    this._greyscaleShader = undefined;\n  }\n\n  destroy() {\n    let p = pipeline_1.Pipeline.get(this._pipeline);\n    if (p) p.onGLContextReset.unbind(this._resetGLContext);\n    this.pause();\n\n    this._resetGLContext();\n  }\n\n  pause() {\n    this._isPaused = true;\n    let p = pipeline_1.Pipeline.get(this._pipeline);\n    if (p && p.currentCameraSource === this) p.currentCameraSource = undefined;\n  }\n\n  start() {\n    var _a;\n\n    if (this._isPaused) {\n      this._isUploadFrame = true;\n      if (this._video instanceof HTMLVideoElement) this._hadFrames = false;\n    }\n\n    this._isPaused = false;\n    let p = pipeline_1.Pipeline.get(this._pipeline);\n\n    if (p && p.currentCameraSource !== this) {\n      (_a = p.currentCameraSource) === null || _a === void 0 ? void 0 : _a.pause();\n      p.currentCameraSource = this;\n    }\n  }\n\n  getFrame(currentlyProcessing) {\n    let pipeline = pipeline_1.Pipeline.get(this._pipeline);\n    if (!pipeline) return;\n    let gl = pipeline.glContext;\n    if (!gl) return;\n    if (this._isPaused) return;\n    if (!this._hadFrames) return;\n\n    try {\n      return this._processFrame(gl, this._cameraToScreenRotation, currentlyProcessing);\n    } catch (ex) {\n      console.log(\"Unable to process frame\");\n    }\n\n    return;\n  }\n\n  _processFrame(gl, rotation, currentlyProcessing) {\n    let pipeline = pipeline_1.Pipeline.get(this._pipeline);\n    if (!pipeline) return undefined;\n\n    if (this._isUploadFrame) {\n      if (!this._currentVideoTexture) {\n        this._currentVideoTexture = pipeline.getVideoTexture();\n      }\n\n      this._uploadFrame(rotation, this._isUserFacing);\n\n      this._isUploadFrame = !this._isUploadFrame;\n      return undefined;\n    }\n\n    if (currentlyProcessing) return undefined;\n    this._isUploadFrame = !this._isUploadFrame;\n    return this._readFrame(pipeline, gl);\n  }\n\n  _uploadFrame(rotation, fc) {\n    if (!this._currentVideoTexture) return;\n    let pipeline = pipeline_1.Pipeline.get(this._pipeline);\n    if (!pipeline) return;\n    let gl = pipeline.glContext;\n    if (!gl) return;\n    gl.disable(gl.SCISSOR_TEST);\n    gl.disable(gl.DEPTH_TEST);\n    gl.disable(gl.BLEND);\n    gl.disable(gl.CULL_FACE);\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, this._currentVideoTexture);\n    const level = 0;\n    const internalFormat = gl.RGBA;\n    const srcFormat = gl.RGBA;\n    const srcType = gl.UNSIGNED_BYTE;\n    gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, srcFormat, srcType, this._video);\n    let videoWidth = 0;\n    let videoHeight = 0;\n\n    if (this._video instanceof HTMLVideoElement) {\n      videoWidth = this._video.videoWidth;\n      videoHeight = this._video.videoHeight;\n    } else {\n      videoWidth = this._video.width;\n      videoHeight = this._video.height;\n    }\n\n    if (videoHeight > videoWidth) videoHeight = [videoWidth, videoWidth = videoHeight][0];\n\n    this._updateTransforms(rotation, fc);\n\n    let framebuffer = this._getFramebuffer(gl, profile_1.profile.dataWidth / 4, profile_1.profile.dataHeight);\n\n    let vbo = this._getVertexBuffer(gl);\n\n    let ibo = this._getIndexBuffer(gl);\n\n    let shader = this._getGreyscaleShader(gl); //     // Rendering to the greyscale conversion buffer - bind the framebuffer\n\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n    gl.viewport(0, 0, this._framebufferWidth, this._framebufferHeight); //     // We'll be replacing all the content - clear is a good hint for this on mobile\n\n    gl.clearColor(0.0, 0.0, 0.0, 1.0);\n    gl.clear(gl.COLOR_BUFFER_BIT); //     // Set up bindings for vertex attributes\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);\n    gl.vertexAttribPointer(shader.aVertexPositionLoc, 2, gl.FLOAT, false, 4 * 4, 0);\n    gl.enableVertexAttribArray(shader.aVertexPositionLoc);\n    gl.vertexAttribPointer(shader.aTextureCoordLoc, 2, gl.FLOAT, false, 4 * 4, 2 * 4);\n    gl.enableVertexAttribArray(shader.aTextureCoordLoc); // Bind the index buffer\n\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo); // Tell WebGL to use our program when drawing\n\n    gl.useProgram(shader.program); // Specify greyscale width for the correct offsets, and the uv transform\n\n    gl.uniform1f(shader.uTexWidthLoc, profile_1.profile.dataWidth);\n    gl.uniformMatrix4fv(shader.uUvTransformLoc, false, this._cameraUvTransform);\n    gl.activeTexture(gl.TEXTURE0); // Bind the texture to texture unit 0\n\n    gl.bindTexture(gl.TEXTURE_2D, this._currentVideoTexture); // Tell the shader we bound the texture to texture unit 0\n\n    gl.uniform1i(shader.uSamplerLoc, 0); // Do the drawing...\n\n    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0); // Disable attribute arrays\n\n    gl.disableVertexAttribArray(shader.aVertexPositionLoc);\n    gl.disableVertexAttribArray(shader.aTextureCoordLoc);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    gl.useProgram(null);\n    gl.bindTexture(gl.TEXTURE_2D, null);\n  }\n\n  _readFrame(p, gl) {\n    if (!this._currentVideoTexture) throw new Error(\"No video texture\");\n    let tex = this._currentVideoTexture;\n    this._currentVideoTexture = undefined;\n    let greySize = profile_1.profile.dataWidth * profile_1.profile.dataHeight;\n    let pixels = p.cameraPixelArrays.pop();\n\n    while (pixels) {\n      if (pixels.byteLength === greySize) break;\n      pixels = p.cameraPixelArrays.pop();\n    }\n\n    if (!pixels) {\n      pixels = new ArrayBuffer(greySize);\n    }\n\n    let pixelsView = new Uint8Array(pixels);\n\n    let framebuffer = this._getFramebuffer(gl, profile_1.profile.dataWidth / 4, profile_1.profile.dataHeight);\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n    gl.readPixels(0, 0, this._framebufferWidth, this._framebufferHeight, gl.RGBA, gl.UNSIGNED_BYTE, pixelsView);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    return {\n      uvTransform: this._cameraUvTransform,\n      data: pixels,\n      texture: tex,\n      dataWidth: profile_1.profile.dataWidth,\n      dataHeight: profile_1.profile.dataHeight,\n      userFacing: this._computedFrontCameraRotation\n    };\n  }\n\n  _updateTransforms(rot, fc) {\n    if (rot == this._computedTransformRotation && fc == this._computedFrontCameraRotation) return;\n    this._computedTransformRotation = rot;\n    this._computedFrontCameraRotation = fc;\n    this._cameraUvTransform = this._getCameraUvTransform();\n    this._cameraVertexTransform = this._getCameraVertexTransform();\n  }\n\n  _getCameraUvTransform() {\n    switch (this._computedTransformRotation) {\n      case 270:\n        return new Float32Array([0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1]);\n\n      case 180:\n        return new Float32Array([-1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1]);\n\n      case 90:\n        return new Float32Array([0, -1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1]);\n    }\n\n    return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n  }\n\n  _getCameraVertexTransform() {\n    let identity = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n    if (!this._computedFrontCameraRotation) return identity; // It's a little odd there's only one special case here.\n    // This is because the camera rotation should really depend on\n    // isFrontCamera as well; we should aim to rotate the camera to\n    // process it in sensor-native orientation and then rotate and\n    // flip for rendering based on the screen orientation.\n    // For now I've kept with the rotation values calculated for the\n    // rear camera and correct the rendering of the front camera here\n    // for all rotations (tested on iPad which allows inverse\n    // portrait).\n    // TODO: Figure this out correctly. Probably need to do this to\n    // correctly use accelerometer / gyro data alongside vision data\n    // regardless of orientation\n\n    switch (this._computedTransformRotation) {\n      case 0:\n      case 90:\n      case 180:\n        identity[0] = -1;\n        break;\n\n      case 270:\n        identity[5] = -1;\n        break;\n    }\n\n    return identity;\n  }\n\n  _getFramebuffer(gl, fbWidth, fbHeight) {\n    if (this._framebufferWidth === fbWidth && this._framebufferHeight === fbHeight && this._framebufferId) return this._framebufferId;\n\n    if (this._framebufferId) {\n      gl.deleteFramebuffer(this._framebufferId);\n      this._framebufferId = null;\n    }\n\n    if (this._renderTexture) {\n      gl.deleteTexture(this._renderTexture);\n      this._renderTexture = null;\n    }\n\n    this._framebufferId = gl.createFramebuffer();\n    if (!this._framebufferId) throw new Error(\"Unable to create framebuffer\");\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebufferId);\n    this._renderTexture = gl.createTexture();\n    if (!this._renderTexture) throw new Error(\"Unable to create render texture\");\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, this._renderTexture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, fbWidth, fbHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._renderTexture, 0);\n    let fbStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n    if (fbStatus !== gl.FRAMEBUFFER_COMPLETE) throw new Error(\"Framebuffer not complete: \" + fbStatus.toString());\n    this._framebufferWidth = fbWidth;\n    this._framebufferHeight = fbHeight;\n    gl.bindTexture(gl.TEXTURE_2D, null);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    return this._framebufferId;\n  }\n\n  _getVertexBuffer(gl) {\n    if (this._vertexBuffer) return this._vertexBuffer;\n    this._vertexBuffer = gl.createBuffer();\n    if (!this._vertexBuffer) throw new Error(\"Unable to create vertex buffer\");\n    gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);\n    let buffer = new Float32Array([-1.0, -1.0, 0.0, 0.0, -1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 0.0]);\n    gl.bufferData(gl.ARRAY_BUFFER, buffer, gl.STATIC_DRAW);\n    return this._vertexBuffer;\n  }\n\n  _getIndexBuffer(gl) {\n    if (this._indexBuffer) return this._indexBuffer;\n    this._indexBuffer = gl.createBuffer();\n    if (!this._indexBuffer) throw new Error(\"Unable to create index buffer\");\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);\n    let buffer = new Uint16Array([0, 1, 2, 0, 2, 3]);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, buffer, gl.STATIC_DRAW);\n    return this._indexBuffer;\n  }\n\n  _getGreyscaleShader(gl) {\n    if (this._greyscaleShader) return this._greyscaleShader;\n    let prog = gl.createProgram();\n    if (!prog) throw new Error(\"Unable to create program\");\n    let vertexShader = shader_1.compileShader(gl, gl.VERTEX_SHADER, greyscaleVsSource);\n    let fragmentShader = shader_1.compileShader(gl, gl.FRAGMENT_SHADER, greyscaleFsSource);\n    gl.attachShader(prog, vertexShader);\n    gl.attachShader(prog, fragmentShader);\n    shader_1.linkProgram(gl, prog);\n    let uTexWidthLoc = gl.getUniformLocation(prog, \"uTexWidth\");\n    if (!uTexWidthLoc) throw new Error(\"Unable to get uniform location uTexWidth\");\n    let uUvTransformLoc = gl.getUniformLocation(prog, \"uUvTransform\");\n    if (!uUvTransformLoc) throw new Error(\"Unable to get uniform location uUvTransform\");\n    let uSamplerLoc = gl.getUniformLocation(prog, \"uSampler\");\n    if (!uSamplerLoc) throw new Error(\"Unable to get uniform location uSampler\");\n    this._greyscaleShader = {\n      program: prog,\n      aVertexPositionLoc: gl.getAttribLocation(prog, \"aVertexPosition\"),\n      aTextureCoordLoc: gl.getAttribLocation(prog, \"aTextureCoord\"),\n      uTexWidthLoc: uTexWidthLoc,\n      uUvTransformLoc: uUvTransformLoc,\n      uSamplerLoc: uSamplerLoc\n    };\n    return this._greyscaleShader;\n  }\n\n}\n\nexports.HTMLElementSource = HTMLElementSource;\nlet greyscaleVsSource = `\n    attribute vec4 aVertexPosition;\n    attribute vec2 aTextureCoord;\n\n    varying highp vec2 vTextureCoord1;\n    varying highp vec2 vTextureCoord2;\n    varying highp vec2 vTextureCoord3;\n    varying highp vec2 vTextureCoord4;\n\n    uniform float uTexWidth;\n\tuniform mat4 uUvTransform;\n\n    void main(void) {\n      highp vec2 offset1 = vec2(1.5 / uTexWidth, 0);\n      highp vec2 offset2 = vec2(0.5 / uTexWidth, 0);\n\n      gl_Position = aVertexPosition;\n      vTextureCoord1 = (uUvTransform * vec4(aTextureCoord - offset1, 0, 1)).xy;\n      vTextureCoord2 = (uUvTransform * vec4(aTextureCoord - offset2, 0, 1)).xy;\n      vTextureCoord3 = (uUvTransform * vec4(aTextureCoord + offset2, 0, 1)).xy;\n      vTextureCoord4 = (uUvTransform * vec4(aTextureCoord + offset1, 0, 1)).xy;\n    }\n`; // Fragment shader program\n\nlet greyscaleFsSource = `\n  varying highp vec2 vTextureCoord1;\n  varying highp vec2 vTextureCoord2;\n  varying highp vec2 vTextureCoord3;\n  varying highp vec2 vTextureCoord4;\n\n  uniform sampler2D uSampler;\n\n  const lowp vec3 colorWeights = vec3(77.0 / 256.0, 150.0 / 256.0, 29.0 / 256.0);\n\n  void main(void) {\n    lowp vec4 outpx;\n\n    outpx.r = dot(colorWeights, texture2D(uSampler, vTextureCoord1).xyz);\n    outpx.g = dot(colorWeights, texture2D(uSampler, vTextureCoord2).xyz);\n    outpx.b = dot(colorWeights, texture2D(uSampler, vTextureCoord3).xyz);\n    outpx.a = dot(colorWeights, texture2D(uSampler, vTextureCoord4).xyz);\n\n    gl_FragColor = outpx;\n  }\n`;","map":{"version":3,"sources":["/Users/hoyiki/Desktop/react-three-example-instant-tracking-cube/node_modules/@zappar/zappar-cv/lib/html-element-source.js"],"names":["Object","defineProperty","exports","value","HTMLElementSource","pipeline_1","require","source_1","profile_1","shader_1","gl_matrix_1","loglevel_1","latest","byId","Map","Source","constructor","_video","_pipeline","_isPaused","_hadFrames","_isUserFacing","_cameraToScreenRotation","_isUploadFrame","_computedTransformRotation","_computedFrontCameraRotation","_cameraUvTransform","mat4","create","_cameraVertexTransform","_framebufferWidth","_framebufferHeight","_framebufferId","_renderTexture","video","HTMLVideoElement","addEventListener","_resetGLContext","bind","p","Pipeline","get","onGLContextReset","createVideoElementSource","element","ret","set","zcout","getVideoElementSource","m","_currentVideoTexture","undefined","_vertexBuffer","_indexBuffer","_greyscaleShader","destroy","unbind","pause","currentCameraSource","start","_a","getFrame","currentlyProcessing","pipeline","gl","glContext","_processFrame","ex","console","log","rotation","getVideoTexture","_uploadFrame","_readFrame","fc","disable","SCISSOR_TEST","DEPTH_TEST","BLEND","CULL_FACE","pixelStorei","UNPACK_FLIP_Y_WEBGL","activeTexture","TEXTURE0","bindTexture","TEXTURE_2D","level","internalFormat","RGBA","srcFormat","srcType","UNSIGNED_BYTE","texImage2D","videoWidth","videoHeight","width","height","_updateTransforms","framebuffer","_getFramebuffer","profile","dataWidth","dataHeight","vbo","_getVertexBuffer","ibo","_getIndexBuffer","shader","_getGreyscaleShader","bindFramebuffer","FRAMEBUFFER","viewport","clearColor","clear","COLOR_BUFFER_BIT","bindBuffer","ARRAY_BUFFER","vertexAttribPointer","aVertexPositionLoc","FLOAT","enableVertexAttribArray","aTextureCoordLoc","ELEMENT_ARRAY_BUFFER","useProgram","program","uniform1f","uTexWidthLoc","uniformMatrix4fv","uUvTransformLoc","uniform1i","uSamplerLoc","drawElements","TRIANGLES","UNSIGNED_SHORT","disableVertexAttribArray","Error","tex","greySize","pixels","cameraPixelArrays","pop","byteLength","ArrayBuffer","pixelsView","Uint8Array","readPixels","uvTransform","data","texture","userFacing","rot","_getCameraUvTransform","_getCameraVertexTransform","Float32Array","identity","fbWidth","fbHeight","deleteFramebuffer","deleteTexture","createFramebuffer","createTexture","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","texParameterf","TEXTURE_MIN_FILTER","LINEAR","framebufferTexture2D","COLOR_ATTACHMENT0","fbStatus","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","toString","createBuffer","buffer","bufferData","STATIC_DRAW","Uint16Array","prog","createProgram","vertexShader","compileShader","VERTEX_SHADER","greyscaleVsSource","fragmentShader","FRAGMENT_SHADER","greyscaleFsSource","attachShader","linkProgram","getUniformLocation","getAttribLocation"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HTMLElementSource = void 0;\nconst pipeline_1 = require(\"./pipeline\");\nconst source_1 = require(\"./source\");\nconst profile_1 = require(\"./profile\");\nconst shader_1 = require(\"./shader\");\nconst gl_matrix_1 = require(\"gl-matrix\");\nconst loglevel_1 = require(\"./loglevel\");\nlet latest = 1;\nlet byId = new Map();\nclass HTMLElementSource extends source_1.Source {\n    constructor(_video, _pipeline) {\n        super();\n        this._video = _video;\n        this._pipeline = _pipeline;\n        this._isPaused = true;\n        this._hadFrames = false;\n        this._isUserFacing = false;\n        this._cameraToScreenRotation = 0;\n        this._isUploadFrame = true;\n        this._computedTransformRotation = -1;\n        this._computedFrontCameraRotation = false;\n        this._cameraUvTransform = gl_matrix_1.mat4.create();\n        this._cameraVertexTransform = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n        this._framebufferWidth = 0;\n        this._framebufferHeight = 0;\n        this._framebufferId = null;\n        this._renderTexture = null;\n        let video = this._video;\n        if (this._video instanceof HTMLVideoElement) {\n            video.addEventListener(\"loadedmetadata\", () => { this._hadFrames = true; });\n        }\n        else {\n            this._hadFrames = true;\n        }\n        this._resetGLContext = this._resetGLContext.bind(this);\n        let p = pipeline_1.Pipeline.get(this._pipeline);\n        if (p)\n            p.onGLContextReset.bind(this._resetGLContext);\n    }\n    static createVideoElementSource(p, element) {\n        let ret = (latest++);\n        byId.set(ret, new HTMLElementSource(element, p));\n        loglevel_1.zcout(\"html_element_source_t initialized\");\n        return ret;\n    }\n    static getVideoElementSource(m) {\n        return byId.get(m);\n    }\n    _resetGLContext() {\n        this._currentVideoTexture = undefined;\n        this._framebufferId = null;\n        this._renderTexture = null;\n        this._vertexBuffer = undefined;\n        this._indexBuffer = undefined;\n        this._greyscaleShader = undefined;\n    }\n    destroy() {\n        let p = pipeline_1.Pipeline.get(this._pipeline);\n        if (p)\n            p.onGLContextReset.unbind(this._resetGLContext);\n        this.pause();\n        this._resetGLContext();\n    }\n    pause() {\n        this._isPaused = true;\n        let p = pipeline_1.Pipeline.get(this._pipeline);\n        if (p && p.currentCameraSource === this)\n            p.currentCameraSource = undefined;\n    }\n    start() {\n        var _a;\n        if (this._isPaused) {\n            this._isUploadFrame = true;\n            if (this._video instanceof HTMLVideoElement)\n                this._hadFrames = false;\n        }\n        this._isPaused = false;\n        let p = pipeline_1.Pipeline.get(this._pipeline);\n        if (p && p.currentCameraSource !== this) {\n            (_a = p.currentCameraSource) === null || _a === void 0 ? void 0 : _a.pause();\n            p.currentCameraSource = this;\n        }\n    }\n    getFrame(currentlyProcessing) {\n        let pipeline = pipeline_1.Pipeline.get(this._pipeline);\n        if (!pipeline)\n            return;\n        let gl = pipeline.glContext;\n        if (!gl)\n            return;\n        if (this._isPaused)\n            return;\n        if (!this._hadFrames)\n            return;\n        try {\n            return this._processFrame(gl, this._cameraToScreenRotation, currentlyProcessing);\n        }\n        catch (ex) {\n            console.log(\"Unable to process frame\");\n        }\n        return;\n    }\n    _processFrame(gl, rotation, currentlyProcessing) {\n        let pipeline = pipeline_1.Pipeline.get(this._pipeline);\n        if (!pipeline)\n            return undefined;\n        if (this._isUploadFrame) {\n            if (!this._currentVideoTexture) {\n                this._currentVideoTexture = pipeline.getVideoTexture();\n            }\n            this._uploadFrame(rotation, this._isUserFacing);\n            this._isUploadFrame = !this._isUploadFrame;\n            return undefined;\n        }\n        if (currentlyProcessing)\n            return undefined;\n        this._isUploadFrame = !this._isUploadFrame;\n        return this._readFrame(pipeline, gl);\n    }\n    _uploadFrame(rotation, fc) {\n        if (!this._currentVideoTexture)\n            return;\n        let pipeline = pipeline_1.Pipeline.get(this._pipeline);\n        if (!pipeline)\n            return;\n        let gl = pipeline.glContext;\n        if (!gl)\n            return;\n        gl.disable(gl.SCISSOR_TEST);\n        gl.disable(gl.DEPTH_TEST);\n        gl.disable(gl.BLEND);\n        gl.disable(gl.CULL_FACE);\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n        gl.activeTexture(gl.TEXTURE0);\n        gl.bindTexture(gl.TEXTURE_2D, this._currentVideoTexture);\n        const level = 0;\n        const internalFormat = gl.RGBA;\n        const srcFormat = gl.RGBA;\n        const srcType = gl.UNSIGNED_BYTE;\n        gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, srcFormat, srcType, this._video);\n        let videoWidth = 0;\n        let videoHeight = 0;\n        if (this._video instanceof HTMLVideoElement) {\n            videoWidth = this._video.videoWidth;\n            videoHeight = this._video.videoHeight;\n        }\n        else {\n            videoWidth = this._video.width;\n            videoHeight = this._video.height;\n        }\n        if (videoHeight > videoWidth)\n            videoHeight = [videoWidth, videoWidth = videoHeight][0];\n        this._updateTransforms(rotation, fc);\n        let framebuffer = this._getFramebuffer(gl, profile_1.profile.dataWidth / 4, profile_1.profile.dataHeight);\n        let vbo = this._getVertexBuffer(gl);\n        let ibo = this._getIndexBuffer(gl);\n        let shader = this._getGreyscaleShader(gl);\n        //     // Rendering to the greyscale conversion buffer - bind the framebuffer\n        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n        gl.viewport(0, 0, this._framebufferWidth, this._framebufferHeight);\n        //     // We'll be replacing all the content - clear is a good hint for this on mobile\n        gl.clearColor(0.0, 0.0, 0.0, 1.0);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n        //     // Set up bindings for vertex attributes\n        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);\n        gl.vertexAttribPointer(shader.aVertexPositionLoc, 2, gl.FLOAT, false, 4 * 4, 0);\n        gl.enableVertexAttribArray(shader.aVertexPositionLoc);\n        gl.vertexAttribPointer(shader.aTextureCoordLoc, 2, gl.FLOAT, false, 4 * 4, 2 * 4);\n        gl.enableVertexAttribArray(shader.aTextureCoordLoc);\n        // Bind the index buffer\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);\n        // Tell WebGL to use our program when drawing\n        gl.useProgram(shader.program);\n        // Specify greyscale width for the correct offsets, and the uv transform\n        gl.uniform1f(shader.uTexWidthLoc, profile_1.profile.dataWidth);\n        gl.uniformMatrix4fv(shader.uUvTransformLoc, false, this._cameraUvTransform);\n        gl.activeTexture(gl.TEXTURE0);\n        // Bind the texture to texture unit 0\n        gl.bindTexture(gl.TEXTURE_2D, this._currentVideoTexture);\n        // Tell the shader we bound the texture to texture unit 0\n        gl.uniform1i(shader.uSamplerLoc, 0);\n        // Do the drawing...\n        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n        // Disable attribute arrays\n        gl.disableVertexAttribArray(shader.aVertexPositionLoc);\n        gl.disableVertexAttribArray(shader.aTextureCoordLoc);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        gl.useProgram(null);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n    }\n    _readFrame(p, gl) {\n        if (!this._currentVideoTexture)\n            throw new Error(\"No video texture\");\n        let tex = this._currentVideoTexture;\n        this._currentVideoTexture = undefined;\n        let greySize = profile_1.profile.dataWidth * profile_1.profile.dataHeight;\n        let pixels = p.cameraPixelArrays.pop();\n        while (pixels) {\n            if (pixels.byteLength === greySize)\n                break;\n            pixels = p.cameraPixelArrays.pop();\n        }\n        if (!pixels) {\n            pixels = new ArrayBuffer(greySize);\n        }\n        let pixelsView = new Uint8Array(pixels);\n        let framebuffer = this._getFramebuffer(gl, profile_1.profile.dataWidth / 4, profile_1.profile.dataHeight);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n        gl.readPixels(0, 0, this._framebufferWidth, this._framebufferHeight, gl.RGBA, gl.UNSIGNED_BYTE, pixelsView);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        return {\n            uvTransform: this._cameraUvTransform,\n            data: pixels,\n            texture: tex,\n            dataWidth: profile_1.profile.dataWidth,\n            dataHeight: profile_1.profile.dataHeight,\n            userFacing: this._computedFrontCameraRotation\n        };\n    }\n    _updateTransforms(rot, fc) {\n        if (rot == this._computedTransformRotation && fc == this._computedFrontCameraRotation)\n            return;\n        this._computedTransformRotation = rot;\n        this._computedFrontCameraRotation = fc;\n        this._cameraUvTransform = this._getCameraUvTransform();\n        this._cameraVertexTransform = this._getCameraVertexTransform();\n    }\n    _getCameraUvTransform() {\n        switch (this._computedTransformRotation) {\n            case 270: return new Float32Array([0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1]);\n            case 180: return new Float32Array([-1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1]);\n            case 90: return new Float32Array([0, -1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1]);\n        }\n        return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n    }\n    _getCameraVertexTransform() {\n        let identity = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n        if (!this._computedFrontCameraRotation)\n            return identity;\n        // It's a little odd there's only one special case here.\n        // This is because the camera rotation should really depend on\n        // isFrontCamera as well; we should aim to rotate the camera to\n        // process it in sensor-native orientation and then rotate and\n        // flip for rendering based on the screen orientation.\n        // For now I've kept with the rotation values calculated for the\n        // rear camera and correct the rendering of the front camera here\n        // for all rotations (tested on iPad which allows inverse\n        // portrait).\n        // TODO: Figure this out correctly. Probably need to do this to\n        // correctly use accelerometer / gyro data alongside vision data\n        // regardless of orientation\n        switch (this._computedTransformRotation) {\n            case 0:\n            case 90:\n            case 180:\n                identity[0] = -1;\n                break;\n            case 270:\n                identity[5] = -1;\n                break;\n        }\n        return identity;\n    }\n    _getFramebuffer(gl, fbWidth, fbHeight) {\n        if (this._framebufferWidth === fbWidth && this._framebufferHeight === fbHeight && this._framebufferId)\n            return this._framebufferId;\n        if (this._framebufferId) {\n            gl.deleteFramebuffer(this._framebufferId);\n            this._framebufferId = null;\n        }\n        if (this._renderTexture) {\n            gl.deleteTexture(this._renderTexture);\n            this._renderTexture = null;\n        }\n        this._framebufferId = gl.createFramebuffer();\n        if (!this._framebufferId)\n            throw new Error(\"Unable to create framebuffer\");\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebufferId);\n        this._renderTexture = gl.createTexture();\n        if (!this._renderTexture)\n            throw new Error(\"Unable to create render texture\");\n        gl.activeTexture(gl.TEXTURE0);\n        gl.bindTexture(gl.TEXTURE_2D, this._renderTexture);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, fbWidth, fbHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._renderTexture, 0);\n        let fbStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n        if (fbStatus !== gl.FRAMEBUFFER_COMPLETE)\n            throw new Error(\"Framebuffer not complete: \" + fbStatus.toString());\n        this._framebufferWidth = fbWidth;\n        this._framebufferHeight = fbHeight;\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        return this._framebufferId;\n    }\n    _getVertexBuffer(gl) {\n        if (this._vertexBuffer)\n            return this._vertexBuffer;\n        this._vertexBuffer = gl.createBuffer();\n        if (!this._vertexBuffer)\n            throw new Error(\"Unable to create vertex buffer\");\n        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);\n        let buffer = new Float32Array([-1.0, -1.0, 0.0, 0.0,\n            -1.0, 1.0, 0.0, 1.0,\n            1.0, 1.0, 1.0, 1.0,\n            1.0, -1.0, 1.0, 0.0]);\n        gl.bufferData(gl.ARRAY_BUFFER, buffer, gl.STATIC_DRAW);\n        return this._vertexBuffer;\n    }\n    _getIndexBuffer(gl) {\n        if (this._indexBuffer)\n            return this._indexBuffer;\n        this._indexBuffer = gl.createBuffer();\n        if (!this._indexBuffer)\n            throw new Error(\"Unable to create index buffer\");\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);\n        let buffer = new Uint16Array([0, 1, 2, 0, 2, 3]);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, buffer, gl.STATIC_DRAW);\n        return this._indexBuffer;\n    }\n    _getGreyscaleShader(gl) {\n        if (this._greyscaleShader)\n            return this._greyscaleShader;\n        let prog = gl.createProgram();\n        if (!prog)\n            throw new Error(\"Unable to create program\");\n        let vertexShader = shader_1.compileShader(gl, gl.VERTEX_SHADER, greyscaleVsSource);\n        let fragmentShader = shader_1.compileShader(gl, gl.FRAGMENT_SHADER, greyscaleFsSource);\n        gl.attachShader(prog, vertexShader);\n        gl.attachShader(prog, fragmentShader);\n        shader_1.linkProgram(gl, prog);\n        let uTexWidthLoc = gl.getUniformLocation(prog, \"uTexWidth\");\n        if (!uTexWidthLoc)\n            throw new Error(\"Unable to get uniform location uTexWidth\");\n        let uUvTransformLoc = gl.getUniformLocation(prog, \"uUvTransform\");\n        if (!uUvTransformLoc)\n            throw new Error(\"Unable to get uniform location uUvTransform\");\n        let uSamplerLoc = gl.getUniformLocation(prog, \"uSampler\");\n        if (!uSamplerLoc)\n            throw new Error(\"Unable to get uniform location uSampler\");\n        this._greyscaleShader = {\n            program: prog,\n            aVertexPositionLoc: gl.getAttribLocation(prog, \"aVertexPosition\"),\n            aTextureCoordLoc: gl.getAttribLocation(prog, \"aTextureCoord\"),\n            uTexWidthLoc: uTexWidthLoc,\n            uUvTransformLoc: uUvTransformLoc,\n            uSamplerLoc: uSamplerLoc\n        };\n        return this._greyscaleShader;\n    }\n}\nexports.HTMLElementSource = HTMLElementSource;\nlet greyscaleVsSource = `\n    attribute vec4 aVertexPosition;\n    attribute vec2 aTextureCoord;\n\n    varying highp vec2 vTextureCoord1;\n    varying highp vec2 vTextureCoord2;\n    varying highp vec2 vTextureCoord3;\n    varying highp vec2 vTextureCoord4;\n\n    uniform float uTexWidth;\n\tuniform mat4 uUvTransform;\n\n    void main(void) {\n      highp vec2 offset1 = vec2(1.5 / uTexWidth, 0);\n      highp vec2 offset2 = vec2(0.5 / uTexWidth, 0);\n\n      gl_Position = aVertexPosition;\n      vTextureCoord1 = (uUvTransform * vec4(aTextureCoord - offset1, 0, 1)).xy;\n      vTextureCoord2 = (uUvTransform * vec4(aTextureCoord - offset2, 0, 1)).xy;\n      vTextureCoord3 = (uUvTransform * vec4(aTextureCoord + offset2, 0, 1)).xy;\n      vTextureCoord4 = (uUvTransform * vec4(aTextureCoord + offset1, 0, 1)).xy;\n    }\n`;\n// Fragment shader program\nlet greyscaleFsSource = `\n  varying highp vec2 vTextureCoord1;\n  varying highp vec2 vTextureCoord2;\n  varying highp vec2 vTextureCoord3;\n  varying highp vec2 vTextureCoord4;\n\n  uniform sampler2D uSampler;\n\n  const lowp vec3 colorWeights = vec3(77.0 / 256.0, 150.0 / 256.0, 29.0 / 256.0);\n\n  void main(void) {\n    lowp vec4 outpx;\n\n    outpx.r = dot(colorWeights, texture2D(uSampler, vTextureCoord1).xyz);\n    outpx.g = dot(colorWeights, texture2D(uSampler, vTextureCoord2).xyz);\n    outpx.b = dot(colorWeights, texture2D(uSampler, vTextureCoord3).xyz);\n    outpx.a = dot(colorWeights, texture2D(uSampler, vTextureCoord4).xyz);\n\n    gl_FragColor = outpx;\n  }\n`;\n"]},"metadata":{},"sourceType":"script"}