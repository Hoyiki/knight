{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Camera = exports.CameraMirrorMode = exports.CameraPoseMode = void 0;\n\nconst Zappar = require(\"@zappar/zappar\");\n\nconst three_1 = require(\"./three\");\n\nconst defaultpipeline_1 = require(\"./defaultpipeline\");\n/**\n * The pose modes that determine how the camera moves around in the scene.\n */\n\n\nvar CameraPoseMode;\n\n(function (CameraPoseMode) {\n  /**\n   * The camera sits, stationary, at the origin of world space, and points down the negative Z axis.\n   * In this mode, tracked anchors move in world space as the user moves the device or tracked objects in the real world.\n   */\n  CameraPoseMode[CameraPoseMode[\"Default\"] = 0] = \"Default\";\n  /**\n   * The camera sits at the origin of world space, but rotates as the user rotates the physical device.\n   *\n   * When the Zappar library initializes, the negative Z axis of world space points forward in front of the user.\n   *\n   * In this mode, tracked anchors move in world space as the user moves the device or tracked objects in the real world.\n   */\n\n  CameraPoseMode[CameraPoseMode[\"Attitude\"] = 1] = \"Attitude\";\n  /**\n   * In this case the camera moves and rotates in world space around the anchor at the origin.\n   */\n\n  CameraPoseMode[CameraPoseMode[\"AnchorOrigin\"] = 2] = \"AnchorOrigin\";\n})(CameraPoseMode = exports.CameraPoseMode || (exports.CameraPoseMode = {}));\n/**\n * The mirror modes that may be used.\n */\n\n\nvar CameraMirrorMode;\n\n(function (CameraMirrorMode) {\n  /**\n   * No mirroring.\n   */\n  CameraMirrorMode[CameraMirrorMode[\"None\"] = 0] = \"None\";\n  /**\n   * This mode mirrors the background camera texture and ensures content still appears correctly tracked.\n   * In this mode your content itself isn't flipped, so any text in your tracked content doesn't appear mirrored.\n   * This is the default mode for the user-facing camera.\n   */\n\n  CameraMirrorMode[CameraMirrorMode[\"Poses\"] = 1] = \"Poses\";\n  /**\n   * In this mode, the Zappar camera applies a scaleX(-1) CSS transform to your whole canvas.\n   * This way both the camera and your content appear mirrored.\n   */\n\n  CameraMirrorMode[CameraMirrorMode[\"CSS\"] = 2] = \"CSS\";\n})(CameraMirrorMode = exports.CameraMirrorMode || (exports.CameraMirrorMode = {}));\n/**\n * Creates a camera that you can use instead of a perspective camera.\n *\n * The camera provides a {@link Camera.backgroundTexture} property containing the camera feed.\n *\n * The ZapparThree library needs to use your WebGL context in order to process camera frames.\n * You can set it when your page loads using {@link glContextSet}.\n * @see https://docs.zap.works/universal-ar/web-libraries/threejs/camera-setup/\n */\n\n\nclass Camera extends three_1.THREE.Camera {\n  /**\n   * Constructs a new Camera.\n   * @param pipeline - The pipeline that this tracker will operate within.\n   * @property pipeline - The pipeline that this tracker will operate within.\n   * @property zNear - The near clipping plane.\n   * @property zFar - The far clipping plane.\n   * @property rearCameraSource? - The camera source which will be used for the rear camera.\n   * @property userCameraSource? - The camera source which will be used for the user camera.\n   */\n  constructor(opts) {\n    super();\n    /**\n     * The camera feed texture.\n     *\n     * You can use this texture however you wish but the easiest way to show the camera feed behind your content is to set it as your scene's background.\n     */\n\n    this.backgroundTexture = new three_1.THREE.Texture();\n    /**\n     * The pose mode that determines how the camera moves in the scene.\n     */\n\n    this.poseMode = CameraPoseMode.Default;\n    /**\n     * The mirror mode that is used for the rear camera.\n     */\n\n    this.rearCameraMirrorMode = CameraMirrorMode.None;\n    /**\n     * The mirror mode that is used for the user camera.\n     */\n\n    this.userCameraMirrorMode = CameraMirrorMode.Poses;\n    this._currentMirrorMode = CameraMirrorMode.None;\n    /**\n     * @ignore\n     * Needed for raycasters to work.\n     */\n\n    this.isPerspectiveCamera = true;\n    this.cameraRunningRear = null;\n    this.hasSetCSSScaleX = false;\n    this.emptyScene = new three_1.THREE.Scene();\n    this.emptyTarget = new three_1.THREE.WebGLRenderTarget(2, 2);\n    this.renderWidth = 0;\n    this.renderHeight = 0;\n    this.pipeline = opts instanceof Zappar.Pipeline ? opts : (opts === null || opts === void 0 ? void 0 : opts.pipeline) || defaultpipeline_1.getDefaultPipeline();\n    this.rawPose = this.pipeline.cameraPoseDefault();\n\n    if (opts && !(opts instanceof Zappar.Pipeline)) {\n      this.zNear = opts.zNear ? opts.zNear : 0.1;\n      this.zFar = opts.zFar ? opts.zFar : 100;\n      this.rearCameraSource = this.cameraSourceFromOpts(opts.rearCameraSource);\n      this.userCameraSource = this.cameraSourceFromOpts(opts.userCameraSource, true);\n    } else {\n      this.rearCameraSource = new defaultpipeline_1.CameraSource(Zappar.cameraDefaultDeviceID(), this.pipeline);\n      this.userCameraSource = new defaultpipeline_1.CameraSource(Zappar.cameraDefaultDeviceID(true), this.pipeline);\n    }\n\n    this.matrixAutoUpdate = false;\n    document.addEventListener(\"visibilitychange\", () => {\n      document.visibilityState === \"visible\" ? this.resume() : this.pause();\n    });\n    const immediate = new three_1.THREE.ImmediateRenderObject(new three_1.THREE.MeshBasicMaterial());\n    this.emptyScene.add(immediate);\n  }\n  /**\n   * Constructs a new CameraSource or HTMLElementSource based on parameters passed in.\n   * @param cameraSource - HTML element or camera device ID which will be used as a source\n   * @returns CameraSource if cameraSource param is undefined or string, otherwise HTMLElementSource.\n   */\n\n\n  cameraSourceFromOpts(cameraSource, frontFacing = false) {\n    return cameraSource instanceof Element ? new Zappar.HTMLElementSource(this.pipeline, cameraSource) : new defaultpipeline_1.CameraSource(cameraSource || Zappar.cameraDefaultDeviceID(frontFacing), this.pipeline);\n  }\n  /**\n   * Pauses the camera source.\n   */\n\n\n  pause() {\n    this.userCameraSource.pause();\n    this.rearCameraSource.pause();\n  }\n  /**\n   * Starts the camera source.\n   *\n   * Starting a given source pauses any other sources within the same pipeline.\n   */\n\n\n  resume() {\n    if (this.cameraRunningRear === null) return;\n    this.cameraRunningRear ? this.rearCameraSource.start() : this.userCameraSource.start();\n  }\n  /**\n   * Starts the camera source.\n   * @param userFacing - If true, starts the user facing camera. (i.e selfie).\n   */\n\n\n  start(userFacing) {\n    userFacing ? this.userCameraSource.start() : this.rearCameraSource.start();\n    this.cameraRunningRear = !userFacing;\n  }\n  /**\n   * Sets the pose mode to 'Anchor Origin'.\n   *\n   * In this case the camera moves and rotates in world space around the anchor at the origin.\n   * @param anchor - The anchor that defines the origin.\n   */\n\n\n  setPoseModeAnchorOrigin(anchor) {\n    this.poseAnchorOrigin = anchor;\n    this.poseMode = CameraPoseMode.AnchorOrigin;\n  }\n  /**\n   * Gets the current mirror mode.\n   */\n\n\n  get currentMirrorMode() {\n    // eslint-disable-next-line no-underscore-dangle\n    return this._currentMirrorMode;\n  }\n  /**\n   * Processes camera frames and updates `backgroundTexture`.\n   * Call this function on your pipeline once an animation frame (e.g. during your `requestAnimationFrame` function).\n   * @param renderer - The Three.js WebGL renderer.\n   */\n\n\n  updateFrame(renderer) {\n    const target = renderer.getRenderTarget();\n    renderer.setRenderTarget(this.emptyTarget);\n    renderer.render(this.emptyScene, this); // ThreeJS manages its GL state for optimal performance\n    // Reset it here so it's predictable for processGL\n\n    renderer.state.reset();\n    this.pipeline.processGL(); // Return to ThreeJS's standard state since processGL will have altered some state\n\n    renderer.state.reset();\n    renderer.setRenderTarget(target); // Update to using the latest tracking frame data\n\n    this.pipeline.frameUpdate(); // eslint-disable-next-line no-underscore-dangle\n\n    this._currentMirrorMode = this.pipeline.cameraFrameUserFacing() ? this.userCameraMirrorMode : this.rearCameraMirrorMode;\n    const {\n      domElement\n    } = renderer;\n\n    if (this.currentMirrorMode !== CameraMirrorMode.CSS && this.hasSetCSSScaleX) {\n      domElement.style.transform = \"\";\n      this.hasSetCSSScaleX = false;\n    } else if (this.currentMirrorMode === CameraMirrorMode.CSS && !this.hasSetCSSScaleX) {\n      domElement.style.transform = \"scaleX(-1)\";\n      this.hasSetCSSScaleX = true;\n    }\n\n    this.renderWidth = renderer.domElement.width;\n    this.renderHeight = renderer.domElement.height; // eslint-disable-next-line no-underscore-dangle\n\n    this._updateProjectionMatrix(); // Get the pose of the camera from the Zappar library\n\n\n    switch (this.poseMode) {\n      case CameraPoseMode.Default:\n        this.rawPose = this.pipeline.cameraPoseDefault();\n        break;\n\n      case CameraPoseMode.Attitude:\n        this.rawPose = this.pipeline.cameraPoseWithAttitude(this.currentMirrorMode === CameraMirrorMode.Poses);\n        break;\n\n      case CameraPoseMode.AnchorOrigin:\n        this.rawPose = this.poseAnchorOrigin ? this.getOriginPose() : this.pipeline.cameraPoseDefault();\n        break;\n\n      default:\n        this.rawPose = this.pipeline.cameraPoseDefault();\n        break;\n    }\n\n    this.updateBackgroundTexture(renderer);\n  } // eslint-disable-next-line no-underscore-dangle\n\n\n  _updateProjectionMatrix() {\n    // Get the projection matrix for the camera from the Zappar library\n    const model = this.pipeline.cameraModel();\n    const projection = Zappar.projectionMatrixFromCameraModel(model, this.renderWidth, this.renderHeight, this.zNear, this.zFar);\n    this.projectionMatrix.fromArray(projection);\n\n    if (typeof this.projectionMatrixInverse.invert === \"function\") {\n      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();\n    } else {\n      this.projectionMatrixInverse.getInverse(this.projectionMatrix);\n    }\n  }\n\n  updateMatrixWorld(force) {\n    this.matrix.fromArray(this.rawPose);\n    this.matrix.decompose(this.position, this.quaternion, this.scale);\n    super.updateMatrixWorld(force);\n  }\n\n  getOriginPose() {\n    if (!this.poseAnchorOrigin) return this.pipeline.cameraPoseDefault();\n    return this.pipeline.cameraPoseWithOrigin(this.poseAnchorOrigin.poseCameraRelative(this.currentMirrorMode === CameraMirrorMode.Poses));\n  }\n\n  updateBackgroundTexture(renderer) {\n    this.pipeline.cameraFrameUploadGL();\n    const texture = this.pipeline.cameraFrameTextureGL();\n    if (!texture) return; // Update the underlying WebGL texture of the ThreeJS texture object\n    // to the one provided by the Zappar library\n\n    const properties = renderer.properties.get(this.backgroundTexture); // eslint-disable-next-line no-underscore-dangle\n\n    properties.__webglTexture = texture; // eslint-disable-next-line no-underscore-dangle\n\n    properties.__webglInit = true; // The Zappar library provides a 4x4 UV matrix to display the camera\n    // texture on a fullscreen quad with 0,0 -> 1,1 UV coordinates\n\n    const view = new three_1.THREE.Matrix4();\n    view.fromArray(this.pipeline.cameraFrameTextureMatrix(renderer.domElement.width, renderer.domElement.height, this.currentMirrorMode === CameraMirrorMode.Poses)); // ThreeJS's Texture object uses a 3x3 matrix, so convert from our 4x4 matrix\n\n    const textureMatrix3 = new three_1.THREE.Matrix3();\n    textureMatrix3.setFromMatrix4(view); // eslint-disable-next-line prefer-destructuring\n\n    textureMatrix3.elements[6] = view.elements[12]; // eslint-disable-next-line prefer-destructuring\n\n    textureMatrix3.elements[7] = view.elements[13];\n    textureMatrix3.elements[8] = 1;\n    this.backgroundTexture.matrixAutoUpdate = false;\n    this.backgroundTexture.matrix = textureMatrix3;\n  }\n  /**\n   * Destroys the camera sources.\n   */\n\n\n  dispose() {\n    this.rearCameraSource.destroy();\n    this.userCameraSource.destroy();\n  }\n\n}\n\nexports.Camera = Camera;","map":{"version":3,"sources":["/Users/hoyiki/Desktop/react-three-example-instant-tracking-cube/node_modules/@zappar/zappar-threejs/lib/camera.js"],"names":["Object","defineProperty","exports","value","Camera","CameraMirrorMode","CameraPoseMode","Zappar","require","three_1","defaultpipeline_1","THREE","constructor","opts","backgroundTexture","Texture","poseMode","Default","rearCameraMirrorMode","None","userCameraMirrorMode","Poses","_currentMirrorMode","isPerspectiveCamera","cameraRunningRear","hasSetCSSScaleX","emptyScene","Scene","emptyTarget","WebGLRenderTarget","renderWidth","renderHeight","pipeline","Pipeline","getDefaultPipeline","rawPose","cameraPoseDefault","zNear","zFar","rearCameraSource","cameraSourceFromOpts","userCameraSource","CameraSource","cameraDefaultDeviceID","matrixAutoUpdate","document","addEventListener","visibilityState","resume","pause","immediate","ImmediateRenderObject","MeshBasicMaterial","add","cameraSource","frontFacing","Element","HTMLElementSource","start","userFacing","setPoseModeAnchorOrigin","anchor","poseAnchorOrigin","AnchorOrigin","currentMirrorMode","updateFrame","renderer","target","getRenderTarget","setRenderTarget","render","state","reset","processGL","frameUpdate","cameraFrameUserFacing","domElement","CSS","style","transform","width","height","_updateProjectionMatrix","Attitude","cameraPoseWithAttitude","getOriginPose","updateBackgroundTexture","model","cameraModel","projection","projectionMatrixFromCameraModel","projectionMatrix","fromArray","projectionMatrixInverse","invert","copy","getInverse","updateMatrixWorld","force","matrix","decompose","position","quaternion","scale","cameraPoseWithOrigin","poseCameraRelative","cameraFrameUploadGL","texture","cameraFrameTextureGL","properties","get","__webglTexture","__webglInit","view","Matrix4","cameraFrameTextureMatrix","textureMatrix3","Matrix3","setFromMatrix4","elements","dispose","destroy"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Camera = exports.CameraMirrorMode = exports.CameraPoseMode = void 0;\nconst Zappar = require(\"@zappar/zappar\");\nconst three_1 = require(\"./three\");\nconst defaultpipeline_1 = require(\"./defaultpipeline\");\n/**\n * The pose modes that determine how the camera moves around in the scene.\n */\nvar CameraPoseMode;\n(function (CameraPoseMode) {\n    /**\n     * The camera sits, stationary, at the origin of world space, and points down the negative Z axis.\n     * In this mode, tracked anchors move in world space as the user moves the device or tracked objects in the real world.\n     */\n    CameraPoseMode[CameraPoseMode[\"Default\"] = 0] = \"Default\";\n    /**\n     * The camera sits at the origin of world space, but rotates as the user rotates the physical device.\n     *\n     * When the Zappar library initializes, the negative Z axis of world space points forward in front of the user.\n     *\n     * In this mode, tracked anchors move in world space as the user moves the device or tracked objects in the real world.\n     */\n    CameraPoseMode[CameraPoseMode[\"Attitude\"] = 1] = \"Attitude\";\n    /**\n     * In this case the camera moves and rotates in world space around the anchor at the origin.\n     */\n    CameraPoseMode[CameraPoseMode[\"AnchorOrigin\"] = 2] = \"AnchorOrigin\";\n})(CameraPoseMode = exports.CameraPoseMode || (exports.CameraPoseMode = {}));\n/**\n * The mirror modes that may be used.\n */\nvar CameraMirrorMode;\n(function (CameraMirrorMode) {\n    /**\n     * No mirroring.\n     */\n    CameraMirrorMode[CameraMirrorMode[\"None\"] = 0] = \"None\";\n    /**\n     * This mode mirrors the background camera texture and ensures content still appears correctly tracked.\n     * In this mode your content itself isn't flipped, so any text in your tracked content doesn't appear mirrored.\n     * This is the default mode for the user-facing camera.\n     */\n    CameraMirrorMode[CameraMirrorMode[\"Poses\"] = 1] = \"Poses\";\n    /**\n     * In this mode, the Zappar camera applies a scaleX(-1) CSS transform to your whole canvas.\n     * This way both the camera and your content appear mirrored.\n     */\n    CameraMirrorMode[CameraMirrorMode[\"CSS\"] = 2] = \"CSS\";\n})(CameraMirrorMode = exports.CameraMirrorMode || (exports.CameraMirrorMode = {}));\n/**\n * Creates a camera that you can use instead of a perspective camera.\n *\n * The camera provides a {@link Camera.backgroundTexture} property containing the camera feed.\n *\n * The ZapparThree library needs to use your WebGL context in order to process camera frames.\n * You can set it when your page loads using {@link glContextSet}.\n * @see https://docs.zap.works/universal-ar/web-libraries/threejs/camera-setup/\n */\nclass Camera extends three_1.THREE.Camera {\n    /**\n     * Constructs a new Camera.\n     * @param pipeline - The pipeline that this tracker will operate within.\n     * @property pipeline - The pipeline that this tracker will operate within.\n     * @property zNear - The near clipping plane.\n     * @property zFar - The far clipping plane.\n     * @property rearCameraSource? - The camera source which will be used for the rear camera.\n     * @property userCameraSource? - The camera source which will be used for the user camera.\n     */\n    constructor(opts) {\n        super();\n        /**\n         * The camera feed texture.\n         *\n         * You can use this texture however you wish but the easiest way to show the camera feed behind your content is to set it as your scene's background.\n         */\n        this.backgroundTexture = new three_1.THREE.Texture();\n        /**\n         * The pose mode that determines how the camera moves in the scene.\n         */\n        this.poseMode = CameraPoseMode.Default;\n        /**\n         * The mirror mode that is used for the rear camera.\n         */\n        this.rearCameraMirrorMode = CameraMirrorMode.None;\n        /**\n         * The mirror mode that is used for the user camera.\n         */\n        this.userCameraMirrorMode = CameraMirrorMode.Poses;\n        this._currentMirrorMode = CameraMirrorMode.None;\n        /**\n         * @ignore\n         * Needed for raycasters to work.\n         */\n        this.isPerspectiveCamera = true;\n        this.cameraRunningRear = null;\n        this.hasSetCSSScaleX = false;\n        this.emptyScene = new three_1.THREE.Scene();\n        this.emptyTarget = new three_1.THREE.WebGLRenderTarget(2, 2);\n        this.renderWidth = 0;\n        this.renderHeight = 0;\n        this.pipeline = opts instanceof Zappar.Pipeline ? opts : (opts === null || opts === void 0 ? void 0 : opts.pipeline) || defaultpipeline_1.getDefaultPipeline();\n        this.rawPose = this.pipeline.cameraPoseDefault();\n        if (opts && !(opts instanceof Zappar.Pipeline)) {\n            this.zNear = opts.zNear ? opts.zNear : 0.1;\n            this.zFar = opts.zFar ? opts.zFar : 100;\n            this.rearCameraSource = this.cameraSourceFromOpts(opts.rearCameraSource);\n            this.userCameraSource = this.cameraSourceFromOpts(opts.userCameraSource, true);\n        }\n        else {\n            this.rearCameraSource = new defaultpipeline_1.CameraSource(Zappar.cameraDefaultDeviceID(), this.pipeline);\n            this.userCameraSource = new defaultpipeline_1.CameraSource(Zappar.cameraDefaultDeviceID(true), this.pipeline);\n        }\n        this.matrixAutoUpdate = false;\n        document.addEventListener(\"visibilitychange\", () => {\n            document.visibilityState === \"visible\" ? this.resume() : this.pause();\n        });\n        const immediate = new three_1.THREE.ImmediateRenderObject(new three_1.THREE.MeshBasicMaterial());\n        this.emptyScene.add(immediate);\n    }\n    /**\n     * Constructs a new CameraSource or HTMLElementSource based on parameters passed in.\n     * @param cameraSource - HTML element or camera device ID which will be used as a source\n     * @returns CameraSource if cameraSource param is undefined or string, otherwise HTMLElementSource.\n     */\n    cameraSourceFromOpts(cameraSource, frontFacing = false) {\n        return cameraSource instanceof Element\n            ? new Zappar.HTMLElementSource(this.pipeline, cameraSource)\n            : new defaultpipeline_1.CameraSource(cameraSource || Zappar.cameraDefaultDeviceID(frontFacing), this.pipeline);\n    }\n    /**\n     * Pauses the camera source.\n     */\n    pause() {\n        this.userCameraSource.pause();\n        this.rearCameraSource.pause();\n    }\n    /**\n     * Starts the camera source.\n     *\n     * Starting a given source pauses any other sources within the same pipeline.\n     */\n    resume() {\n        if (this.cameraRunningRear === null)\n            return;\n        this.cameraRunningRear ? this.rearCameraSource.start() : this.userCameraSource.start();\n    }\n    /**\n     * Starts the camera source.\n     * @param userFacing - If true, starts the user facing camera. (i.e selfie).\n     */\n    start(userFacing) {\n        userFacing ? this.userCameraSource.start() : this.rearCameraSource.start();\n        this.cameraRunningRear = !userFacing;\n    }\n    /**\n     * Sets the pose mode to 'Anchor Origin'.\n     *\n     * In this case the camera moves and rotates in world space around the anchor at the origin.\n     * @param anchor - The anchor that defines the origin.\n     */\n    setPoseModeAnchorOrigin(anchor) {\n        this.poseAnchorOrigin = anchor;\n        this.poseMode = CameraPoseMode.AnchorOrigin;\n    }\n    /**\n     * Gets the current mirror mode.\n     */\n    get currentMirrorMode() {\n        // eslint-disable-next-line no-underscore-dangle\n        return this._currentMirrorMode;\n    }\n    /**\n     * Processes camera frames and updates `backgroundTexture`.\n     * Call this function on your pipeline once an animation frame (e.g. during your `requestAnimationFrame` function).\n     * @param renderer - The Three.js WebGL renderer.\n     */\n    updateFrame(renderer) {\n        const target = renderer.getRenderTarget();\n        renderer.setRenderTarget(this.emptyTarget);\n        renderer.render(this.emptyScene, this);\n        // ThreeJS manages its GL state for optimal performance\n        // Reset it here so it's predictable for processGL\n        renderer.state.reset();\n        this.pipeline.processGL();\n        // Return to ThreeJS's standard state since processGL will have altered some state\n        renderer.state.reset();\n        renderer.setRenderTarget(target);\n        // Update to using the latest tracking frame data\n        this.pipeline.frameUpdate();\n        // eslint-disable-next-line no-underscore-dangle\n        this._currentMirrorMode = this.pipeline.cameraFrameUserFacing() ? this.userCameraMirrorMode : this.rearCameraMirrorMode;\n        const { domElement } = renderer;\n        if (this.currentMirrorMode !== CameraMirrorMode.CSS && this.hasSetCSSScaleX) {\n            domElement.style.transform = \"\";\n            this.hasSetCSSScaleX = false;\n        }\n        else if (this.currentMirrorMode === CameraMirrorMode.CSS && !this.hasSetCSSScaleX) {\n            domElement.style.transform = \"scaleX(-1)\";\n            this.hasSetCSSScaleX = true;\n        }\n        this.renderWidth = renderer.domElement.width;\n        this.renderHeight = renderer.domElement.height;\n        // eslint-disable-next-line no-underscore-dangle\n        this._updateProjectionMatrix();\n        // Get the pose of the camera from the Zappar library\n        switch (this.poseMode) {\n            case CameraPoseMode.Default:\n                this.rawPose = this.pipeline.cameraPoseDefault();\n                break;\n            case CameraPoseMode.Attitude:\n                this.rawPose = this.pipeline.cameraPoseWithAttitude(this.currentMirrorMode === CameraMirrorMode.Poses);\n                break;\n            case CameraPoseMode.AnchorOrigin:\n                this.rawPose = this.poseAnchorOrigin ? this.getOriginPose() : this.pipeline.cameraPoseDefault();\n                break;\n            default:\n                this.rawPose = this.pipeline.cameraPoseDefault();\n                break;\n        }\n        this.updateBackgroundTexture(renderer);\n    }\n    // eslint-disable-next-line no-underscore-dangle\n    _updateProjectionMatrix() {\n        // Get the projection matrix for the camera from the Zappar library\n        const model = this.pipeline.cameraModel();\n        const projection = Zappar.projectionMatrixFromCameraModel(model, this.renderWidth, this.renderHeight, this.zNear, this.zFar);\n        this.projectionMatrix.fromArray(projection);\n        if (typeof this.projectionMatrixInverse.invert === \"function\") {\n            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();\n        }\n        else {\n            this.projectionMatrixInverse.getInverse(this.projectionMatrix);\n        }\n    }\n    updateMatrixWorld(force) {\n        this.matrix.fromArray(this.rawPose);\n        this.matrix.decompose(this.position, this.quaternion, this.scale);\n        super.updateMatrixWorld(force);\n    }\n    getOriginPose() {\n        if (!this.poseAnchorOrigin)\n            return this.pipeline.cameraPoseDefault();\n        return this.pipeline.cameraPoseWithOrigin(this.poseAnchorOrigin.poseCameraRelative(this.currentMirrorMode === CameraMirrorMode.Poses));\n    }\n    updateBackgroundTexture(renderer) {\n        this.pipeline.cameraFrameUploadGL();\n        const texture = this.pipeline.cameraFrameTextureGL();\n        if (!texture)\n            return;\n        // Update the underlying WebGL texture of the ThreeJS texture object\n        // to the one provided by the Zappar library\n        const properties = renderer.properties.get(this.backgroundTexture);\n        // eslint-disable-next-line no-underscore-dangle\n        properties.__webglTexture = texture;\n        // eslint-disable-next-line no-underscore-dangle\n        properties.__webglInit = true;\n        // The Zappar library provides a 4x4 UV matrix to display the camera\n        // texture on a fullscreen quad with 0,0 -> 1,1 UV coordinates\n        const view = new three_1.THREE.Matrix4();\n        view.fromArray(this.pipeline.cameraFrameTextureMatrix(renderer.domElement.width, renderer.domElement.height, this.currentMirrorMode === CameraMirrorMode.Poses));\n        // ThreeJS's Texture object uses a 3x3 matrix, so convert from our 4x4 matrix\n        const textureMatrix3 = new three_1.THREE.Matrix3();\n        textureMatrix3.setFromMatrix4(view);\n        // eslint-disable-next-line prefer-destructuring\n        textureMatrix3.elements[6] = view.elements[12];\n        // eslint-disable-next-line prefer-destructuring\n        textureMatrix3.elements[7] = view.elements[13];\n        textureMatrix3.elements[8] = 1;\n        this.backgroundTexture.matrixAutoUpdate = false;\n        this.backgroundTexture.matrix = textureMatrix3;\n    }\n    /**\n     * Destroys the camera sources.\n     */\n    dispose() {\n        this.rearCameraSource.destroy();\n        this.userCameraSource.destroy();\n    }\n}\nexports.Camera = Camera;\n"]},"metadata":{},"sourceType":"script"}