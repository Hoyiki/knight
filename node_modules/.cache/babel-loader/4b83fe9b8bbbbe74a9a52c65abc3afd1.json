{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FaceBufferGeometry = void 0;\n\nconst three_1 = require(\"../three\");\n\nconst facemeshloader_1 = require(\"../loaders/facemeshloader\");\n\nlet faceMeshSingleton;\n/**\n * A THREE.BufferGeometry that fits to the user's face and deforms as the user's expression changes.\n * @see https://docs.zap.works/universal-ar/web-libraries/threejs/face-tracking/\n */\n\nclass FaceBufferGeometry extends three_1.THREE.BufferGeometry {\n  /**\n   * Constructs a new FaceBufferGeometry.\n   * @param faceMesh - The face mesh which will be used. If not specified, the default face mesh will be loaded.\n   */\n  constructor(faceMesh) {\n    super();\n    this.hasSetIndices = false;\n    this.hasSetUVs = false;\n    this.recalculateNormals = true;\n\n    if (!faceMesh) {\n      if (!faceMeshSingleton) {\n        faceMeshSingleton = new facemeshloader_1.FaceMeshLoader().load();\n      } // eslint-disable-next-line no-param-reassign\n\n\n      faceMesh = faceMeshSingleton;\n    }\n\n    this._faceMesh = faceMesh;\n  }\n\n  _updateIndices() {\n    if (this.hasSetIndices) return;\n    if (this._faceMesh.indices.length === 0) return;\n    this.setIndex(new three_1.THREE.Uint16BufferAttribute(this._faceMesh.indices, 1));\n    this.hasSetIndices = true;\n  }\n\n  _updateUVs() {\n    if (this.hasSetUVs) return;\n    if (this._faceMesh.uvs.length === 0) return;\n    this.setAttribute(\"uv\", new three_1.THREE.BufferAttribute(this._faceMesh.uvs, 2));\n    this.hasSetUVs = true;\n  }\n  /**\n   * @ignore\n   */\n\n\n  get calculateNormals() {\n    return this.recalculateNormals;\n  }\n  /**\n   * @ignore\n   */\n\n\n  set calculateNormals(b) {\n    this.recalculateNormals = b;\n\n    if (!this.recalculateNormals) {\n      if (typeof this.removeAttribute === \"function\") {\n        this.removeAttribute(\"normal\");\n      }\n\n      delete this.normals;\n    }\n  }\n  /**\n   * Updates the geometry to the most recent identity and expression output from a face anchor group.\n   * @param f - The face anchor group which will be used to update the geometry.\n   */\n\n\n  updateFromFaceAnchorGroup(f) {\n    if (this._faceMesh.vertices.length === 0) return;\n    if (!f.currentAnchor) return;\n    this.updateFromFaceAnchor(f.currentAnchor);\n  }\n  /**\n   * Updates the geometry to the most recent identity and expression output from a face anchor.\n   * @param f - The face anchor which will be used to update the geometry.\n   */\n\n\n  updateFromFaceAnchor(f) {\n    this.updateFromIdentityExpression(f.identity, f.expression);\n  }\n  /**\n   * Updates the geometry to the provided identity and expression coefficients.\n   * @param identity  - The identity coefficients.\n   * @param expression - The expression coefficients.\n   */\n\n\n  updateFromIdentityExpression(identity, expression) {\n    if (this._faceMesh.vertices.length === 0) return;\n\n    this._updateIndices();\n\n    this._updateUVs();\n\n    this._faceMesh.updateFromIdentityExpression(identity, expression);\n\n    if (!this.vertices) {\n      this.vertices = new Float32Array(this._faceMesh.vertices.length);\n      this.verticesAttribute = new three_1.THREE.BufferAttribute(this.vertices, 3);\n      this.setAttribute(\"position\", this.verticesAttribute);\n    }\n\n    this.vertices.set(this._faceMesh.vertices);\n    if (this.verticesAttribute) this.verticesAttribute.needsUpdate = true;\n    this.computeBoundingSphere();\n    if (!this.calculateNormals) return;\n\n    if (!this.normals) {\n      this.normals = new Float32Array(this._faceMesh.normals.length);\n      this.normalsAttribute = new three_1.THREE.BufferAttribute(this.normals, 3);\n      this.setAttribute(\"normal\", this.normalsAttribute);\n    }\n\n    this.normals.set(this._faceMesh.normals);\n    if (this.normalsAttribute) this.normalsAttribute.needsUpdate = true;\n  }\n\n}\n\nexports.FaceBufferGeometry = FaceBufferGeometry;","map":{"version":3,"sources":["/Users/hoyiki/Desktop/react-three-example-instant-tracking-cube/node_modules/@zappar/zappar-threejs/lib/geometry/facebuffergeometry.js"],"names":["Object","defineProperty","exports","value","FaceBufferGeometry","three_1","require","facemeshloader_1","faceMeshSingleton","THREE","BufferGeometry","constructor","faceMesh","hasSetIndices","hasSetUVs","recalculateNormals","FaceMeshLoader","load","_faceMesh","_updateIndices","indices","length","setIndex","Uint16BufferAttribute","_updateUVs","uvs","setAttribute","BufferAttribute","calculateNormals","b","removeAttribute","normals","updateFromFaceAnchorGroup","f","vertices","currentAnchor","updateFromFaceAnchor","updateFromIdentityExpression","identity","expression","Float32Array","verticesAttribute","set","needsUpdate","computeBoundingSphere","normalsAttribute"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FaceBufferGeometry = void 0;\nconst three_1 = require(\"../three\");\nconst facemeshloader_1 = require(\"../loaders/facemeshloader\");\nlet faceMeshSingleton;\n/**\n * A THREE.BufferGeometry that fits to the user's face and deforms as the user's expression changes.\n * @see https://docs.zap.works/universal-ar/web-libraries/threejs/face-tracking/\n */\nclass FaceBufferGeometry extends three_1.THREE.BufferGeometry {\n    /**\n     * Constructs a new FaceBufferGeometry.\n     * @param faceMesh - The face mesh which will be used. If not specified, the default face mesh will be loaded.\n     */\n    constructor(faceMesh) {\n        super();\n        this.hasSetIndices = false;\n        this.hasSetUVs = false;\n        this.recalculateNormals = true;\n        if (!faceMesh) {\n            if (!faceMeshSingleton) {\n                faceMeshSingleton = new facemeshloader_1.FaceMeshLoader().load();\n            }\n            // eslint-disable-next-line no-param-reassign\n            faceMesh = faceMeshSingleton;\n        }\n        this._faceMesh = faceMesh;\n    }\n    _updateIndices() {\n        if (this.hasSetIndices)\n            return;\n        if (this._faceMesh.indices.length === 0)\n            return;\n        this.setIndex(new three_1.THREE.Uint16BufferAttribute(this._faceMesh.indices, 1));\n        this.hasSetIndices = true;\n    }\n    _updateUVs() {\n        if (this.hasSetUVs)\n            return;\n        if (this._faceMesh.uvs.length === 0)\n            return;\n        this.setAttribute(\"uv\", new three_1.THREE.BufferAttribute(this._faceMesh.uvs, 2));\n        this.hasSetUVs = true;\n    }\n    /**\n     * @ignore\n     */\n    get calculateNormals() {\n        return this.recalculateNormals;\n    }\n    /**\n     * @ignore\n     */\n    set calculateNormals(b) {\n        this.recalculateNormals = b;\n        if (!this.recalculateNormals) {\n            if (typeof this.removeAttribute === \"function\") {\n                this.removeAttribute(\"normal\");\n            }\n            delete this.normals;\n        }\n    }\n    /**\n     * Updates the geometry to the most recent identity and expression output from a face anchor group.\n     * @param f - The face anchor group which will be used to update the geometry.\n     */\n    updateFromFaceAnchorGroup(f) {\n        if (this._faceMesh.vertices.length === 0)\n            return;\n        if (!f.currentAnchor)\n            return;\n        this.updateFromFaceAnchor(f.currentAnchor);\n    }\n    /**\n     * Updates the geometry to the most recent identity and expression output from a face anchor.\n     * @param f - The face anchor which will be used to update the geometry.\n     */\n    updateFromFaceAnchor(f) {\n        this.updateFromIdentityExpression(f.identity, f.expression);\n    }\n    /**\n     * Updates the geometry to the provided identity and expression coefficients.\n     * @param identity  - The identity coefficients.\n     * @param expression - The expression coefficients.\n     */\n    updateFromIdentityExpression(identity, expression) {\n        if (this._faceMesh.vertices.length === 0)\n            return;\n        this._updateIndices();\n        this._updateUVs();\n        this._faceMesh.updateFromIdentityExpression(identity, expression);\n        if (!this.vertices) {\n            this.vertices = new Float32Array(this._faceMesh.vertices.length);\n            this.verticesAttribute = new three_1.THREE.BufferAttribute(this.vertices, 3);\n            this.setAttribute(\"position\", this.verticesAttribute);\n        }\n        this.vertices.set(this._faceMesh.vertices);\n        if (this.verticesAttribute)\n            this.verticesAttribute.needsUpdate = true;\n        this.computeBoundingSphere();\n        if (!this.calculateNormals)\n            return;\n        if (!this.normals) {\n            this.normals = new Float32Array(this._faceMesh.normals.length);\n            this.normalsAttribute = new three_1.THREE.BufferAttribute(this.normals, 3);\n            this.setAttribute(\"normal\", this.normalsAttribute);\n        }\n        this.normals.set(this._faceMesh.normals);\n        if (this.normalsAttribute)\n            this.normalsAttribute.needsUpdate = true;\n    }\n}\nexports.FaceBufferGeometry = FaceBufferGeometry;\n"]},"metadata":{},"sourceType":"script"}